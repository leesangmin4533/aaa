# README

이 문서는 프로젝트의 여러 개별 문서를 하나로 묶은 통합 버전입니다.


## README
# BGF Retail Automation (Nexacro-Optimized)

이 저장소는 BGF 리테일 시스템의 "중분류별 매출 구성비" 페이지 데이터 수집을 자동화하는 프로젝트입니다. Nexacro API를 직접 활용하여 안정성과 속도를 높이는 데 중점을 두었습니다.

## 주요 기능

- **안정적인 데이터 수집**: 화면의 HTML을 파싱하는 대신, Nexacro의 내부 데이터 저장소인 `Dataset`에 직접 접근하여 데이터를 빠르고 정확하게 수집합니다.
- **지능적인 동기화**: `delay`를 사용한 무작정 대기 대신, 데이터 통신 완료 시점을 알려주는 트랜잭션 콜백(Callback)을 활용하여 불필요한 대기 시간을 제거하고 신뢰성을 높였습니다.
- **날짜별 DB 관리**: 데이터는 날짜별로 독립된 DB 파일(예: `20250718.db`)에 저장됩니다. 날짜가 바뀌면 새로운 DB 파일이 생성됩니다.
- **중복 방지 및 데이터 검증**: 
  - 동일 날짜/상품 코드의 데이터는 sales 증가 시에만 저장
  - 수집 시각은 분 단위까지 정확히 기록 (YYYY-MM-DD HH:MM)
- **자동 과거 데이터 수집**: `main.py` 실행 시, 최근 2일 중 누락된 날짜의 데이터를 자동으로 수집합니다.
- **자동 로그인 및 팝업 처리**: 설정된 정보를 통해 자동으로 로그인하고, 과정에서 나타나는 팝업을 닫습니다.

## 설정

### 1. `config.json`

프로젝트의 주요 설정은 루트 디렉토리의 `config.json` 파일을 통해 관리됩니다.

```json
{
    "db_file": "code_outputs/db/integrated_sales.db",
    "scripts": {
        "default": "nexacro_automation_library.js",
        "listener": "data_collect_listener.js",
        "navigation": "navigation.js"
    },
    "field_order": [
        "midCode", "midName", "productCode", "productName", 
        "sales", "order_cnt", "purchase", "disposal", "stock"
    ],
    "timeouts": {
        "data_collection": 300,
        "page_load": 120
    },
    "cycle_interval_seconds": 60,
    "log_file": "logs/automation.log"
}
```

- `db_file`: 모든 데이터가 저장될 통합 SQLite DB 파일 경로입니다.
- `scripts`: 자동화에 사용될 JavaScript 파일 목록입니다.
  - `default`: 핵심 데이터 수집 로직이 담긴 Nexacro 최적화 라이브러리입니다.
  - `listener`: 실시간 DOM 변화를 감지하여 데이터를 수집하는 스크립트입니다.
  - `date_changer`: 날짜를 변경하고 조회 버튼을 누르는 스크립트입니다.
  - `navigation`: 목표 페이지로 이동하는 스크립트입니다.

### 2. 로그인 정보

로그인 정보는 `.env` 파일 또는 시스템 환경 변수를 통해 설정할 수 있습니다.

- **`.env` 파일 (권장)**: 프로젝트 루트에 `.env` 파일을 만들고 아래와 같이 작성합니다.
  ```env
  BGF_USER_ID=your_id
  BGF_PASSWORD=your_password
  ```

## 사용법

먼저 아래 명령어로 프로젝트 의존성을 설치한 뒤 자동화를 시작합니다.

```bash
pip install -r requirements.txt
python -m aaa
# 또는
python main.py
```

`main.py`는 다음 순서로 작업을 수행합니다.

1.  **과거 데이터 확인**: 통합 DB에 최근 2일치 데이터 중 누락된 날짜가 있는지 확인합니다.
2.  **과거 데이터 수집**: 누락된 날짜가 있다면, 가장 오래된 날짜부터 순서대로 해당 날짜의 데이터 수집 사이클을 실행합니다.
3.  **현재 데이터 수집**: 과거 데이터 처리가 끝나면, 오늘 날짜의 데이터 수집 사이클을 실행합니다.

각 수집 사이클(`_run_collection_cycle`)은 다음처럼 동작합니다.
- Chrome 드라이버를 실행하고 로그인합니다.
- `nexacro_automation_library.js`를 브라우저에 주입합니다.
- `date_changer.js`를 로드해 날짜 변경 기능을 준비합니다.
- `navigation.js`를 실행하여 목표 페이지로 이동합니다.
- `window.automation.runCollectionForDate('YYYYMMDD')` 함수를 호출하여 데이터 수집을 시작합니다.
- 수집된 데이터는 통합 DB에 저장됩니다.

## 의존성 설치 및 테스트

프로젝트에서 필요한 패키지는 `requirements.txt` 파일에 정의되어 있습니다. 다음 명령어로 설치할 수 있습니다.

```bash
pip install -r requirements.txt
```

테스트는 `pytest`를 사용하여 실행합니다.

```bash
pytest
```

## 데이터 포맷

JavaScript 스크립트에서 수집한 각 상품 데이터는 다음과 같은 필드를 포함한 객체 형태로 Python에 전달됩니다.

| 키 이름        | 설명             |
|----------------|------------------|
| `midCode`      | 중분류 코드      |
| `midName`      | 중분류명         |
| `productCode`  | 상품 코드        |
| `productName`  | 상품명           |
| `sales`        | 매출액           |
| `order_cnt`    | 주문수량         |
| `purchase`     | 매입액           |
| `disposal`     | 폐기액           |
| `stock`        | 재고액           |

`write_sales_data` 함수는 위 필드명 외에도 `snake_case` 형태(`mid_code` 등)나 기존 텍스트 파일 포맷(`order`, `discard`)을 허용합니다.

## 데이터베이스 구조

`mid_sales` 테이블에 데이터가 저장되며, 중복 저장을 방지하기 위한 제약 조건이 포함되어 있습니다.

```sql
CREATE TABLE IF NOT EXISTS mid_sales (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    collected_at TEXT,        -- 수집 시간 (YYYY-MM-DD HH:MM)
    mid_code TEXT,           -- 중분류 코드
    mid_name TEXT,           -- 중분류명
    product_code TEXT,       -- 상품 코드
    product_name TEXT,       -- 상품명
    sales INTEGER,           -- 매출액
    order_cnt INTEGER,       -- 주문수량
    purchase INTEGER,        -- 매입액
    disposal INTEGER,        -- 폐기액
    stock INTEGER,           -- 재고액
    UNIQUE(collected_at, product_code) -- 이 조합은 고유해야 함
);
```

## 자동화 스크립트 상세 (`nexacro_automation_library.js`)

이 프로젝트의 핵심은 DOM 요소를 직접 제어하는 대신 Nexacro 프레임워크의 내부 API를 활용하는 것입니다.

- **`Dataset` 직접 접근**: 화면에 보이는 그리드(Grid)의 HTML을 읽는 대신, 그리드에 연결된 내부 데이터 저장소(`Dataset`)에 직접 접근합니다. 이를 통해 스크롤 없이 모든 데이터를 한 번에, 빠르고 정확하게 가져올 수 있습니다.
- **트랜잭션 콜백 기반 동기화**: `delay()`를 사용한 대기 대신, Nexacro의 데이터 통신(Transaction) 완료 신호(`fn_callback`)를 감지하여, 데이터 로딩이 완료되는 정확한 시점에 다음 동작을 수행합니다.
- **안정적인 컴포넌트 제어**: `lookup()`, `set_rowposition()`, `triggerEvent()` 등 Nexacro 내부 API를 사용하여 컴포넌트를 안정적으로 제어합니다.
## 프로젝트 요약
자세한 요약은 PROJECT_SUMMARY.txt 파일을 참조하세요.

더 자세한 실행 흐름은 `BGF_Automation_Flow.md` 문서를 참고하세요.
\n## BGF_Automation_Flow.md
# BGF 자동화 프로젝트: 주요 흐름 및 아키텍처

이 문서는 BGF 자동화 프로젝트의 전반적인 데이터 수집 및 처리 흐름을 설명합니다.

## 1. 실행 순서

1. **시작**: 사용자가 `python main.py`를 실행합니다.
2. **로그 초기화**: `utils/log_util.py`가 `logs/automation.log` 파일을 매 실행 시 새로 만듭니다.
3. **드라이버 생성**: `main.py`에서 Selenium WebDriver 인스턴스를 생성합니다.
4. **로그인 및 팝업 처리**: `login/login_bgf.py`로 로그인 후 `utils/popup_util.py`로 팝업을 닫습니다.
5. **스크립트 주입**: `scripts/nexacro_automation_library.js`를 읽어 브라우저에 삽입합니다.
6. **과거 데이터 확인**:
   - `main.py`의 `is_past_data_available` 함수가 최근 2일 데이터 필요 여부를 결정합니다.
   - 내부적으로 `utils/db_util.py`의 `check_dates_exist`를 호출해 `code_outputs/db/integrated_sales.db`에 데이터가 있는지 확인합니다.
   - 없으면 먼저 과거 데이터를 수집합니다.
7. **메인 데이터 수집**:
   - `runCollectionForDate()` 함수를 호출해 오늘 데이터를 수집합니다.
   - JavaScript 로직은 Dataset에 직접 접근해 중분류 목록과 상품 목록을 추출하고, 검증 후 `window.automation.parsedData`에 저장합니다.
8. **데이터베이스 저장**:
   - Python에서 `window.automation.parsedData` 값을 읽어 `utils/db_util.py`의 `write_sales_data`로 DB에 저장합니다.
   - 이미 존재하는 상품의 경우 더 큰 판매량만 갱신합니다.
9. **판매량 예측**: `utils/db_util.py`의 `run_jumeokbap_prediction_and_save`가 내일의 주먹밥 판매량을 예측해 저장합니다.
10. **종료**: WebDriver를 종료하고 모든 과정을 마칩니다.

## 2. 주요 파일 역할

- **main.py**: 전체 과정을 지휘하는 오케스트레이터.
- **scripts/nexacro_automation_library.js**: Nexacro 환경 제어와 데이터 추출을 담당하는 핵심 스크립트.
- **utils/db_util.py**: SQLite DB 관리와 판매량 예측 로직 담당.
- **utils/log_util.py**: 로그 기록 관리.
- **config.json**: 프로젝트 설정 파일.

## 3. 데이터 흐름

```
Nexacro Dataset
      ↓ (1. JS가 추출)
임시 변수(Map)
      ↓ (2. 검증 후 전역 변수 저장)
window.automation.parsedData
      ↓ (3. Python으로 전달)
collected 변수(List[Dict])
      ↓ (4. DB 저장)
code_outputs/db/integrated_sales.db
```
\n## Nexacro_Mix_Ratio_Structure.md
# 📘 Nexacro 중분류별 매출 구성비 구조 문서 (2025-07-07 기준)

## 🧭 상위 구조 계층 (Frame → Form → Component)

nexacro.getApplication().mainframe
└── frames[]                    // 열려 있는 화면 목록
    └── [WorkFrame]._form      // 현재 실행 중인 화면 Form
        └── components
            ├── gdList         ← 중분류 코드 리스트 (좌측 그리드)
            └── gdDetail       ← 상품 목록 (우측 그리드)

## ✅ 좌측: 중분류 코드 그리드 `gdList`

| 항목 | 설명 |
|------|------|
| 구성 | 중분류 코드, 분류명, 수량, 금액, 구성비 등 |
| 행 구조 | `gridrow_{n}` |
| 열 구조 | `cell_{n}_{col}` |
| 주요 셀 예시 |
| - 코드 "019" | `gdList.gridrow_9.cell_9_0:text` |
| - 분류명 "초콜릿" | `gdList.gridrow_9.cell_9_1:text` |
| 클릭 대상 | `:text` 없는 `cell_9_0` div (이벤트 전송 대상) |

## ✅ 우측: 상품 목록 그리드 `gdDetail`

| 항목 | 설명 |
|------|------|
| 구성 | 중분류별 상품 상세 정보 |
| 표시 행 수 | 한 화면에 4행 (스크롤로 추가 불러오기 가능) |
| 행 구조 | 행 컨테이너는 항상 `gridrow_0` 하나이며 각 행 셀의 ID는 `cell_{row}_{col}` 형태로 표시됨 |
| 열 구조 | `cell_{row}_{col}` |
| 텍스트 셀 | `cell_{row}_{col}:text` |

### 🔢 열 인덱스 (col 번호별 항목)

| 열(col) | 항목명     | 예시 ID |
|---------|------------|----------|
| 0       | 상품코드   | `cell_0_0:text` |
| 1       | 상품명     | `cell_0_1:text` |
| 2       | 매출       | `cell_0_2:text` |
| 3       | 발주       | `cell_0_3:text` |
| 4       | 매입       | `cell_0_4:text` |
| 5       | 폐기       | `cell_0_5:text` |
| 6       | 현재고     | `cell_0_6:text` |

## ✅ 스크롤 구성

| 구성 요소 | ID 예시 | 설명 |
|------------|----------|------|
| 스크롤 버튼 | `incbutton:icontext` | 클릭 시 다음 4행 로딩됨 |
| 스크롤 후에도 DOM 구조는 동일 | `gridrow_0` | 다음 4행은 `gridrow_0 ~ 3`로 다시 채워짐 (이전 내용 덮어쓰기됨) |

## 🧩 작동 흐름 요약

1. **중분류 코드 클릭** → `gdList.cell_{n}_0` 클릭
2. → Nexacro 트랜잭션 (`searchDetail`) 발생
3. → `gdDetail`에 4개의 상품 정보 표시
4. **스크롤 버튼 클릭 시** → 다음 4행 데이터로 교체

## ✅ DOM ID 패턴 요약표

| 대상 | DOM ID 패턴 |
|------|--------------|
| 중분류 코드 | `gdList.gridrow_0.cell_{n}_0[:text]` |
| 중분류명 | `gdList.gridrow_0.cell_{n}_1:text` |
| 상품코드 | `gdDetail.gridrow_0.cell_{n}_0:text` |
| 상품명 | `gdDetail.gridrow_0.cell_{n}_1:text` |
| 기타 항목 | `gdDetail.gridrow_0.cell_{n}_{col}:text` |

## ✅ 예시 콘솔 명령 요약 (기억용)

### 중분류 '019' 클릭
dispatchMouseEventTo('gdList.gridrow_9.cell_9_0');

### 중분류명 추출
document.querySelector('div[id*="gdList"][id*="cell_9_1:text"]')?.innerText;

### 상품코드 4개 추출
for (let i = 0; i < 4; i++) {
  console.log(document.querySelector(`div[id*="gdDetail"][id*="cell_${i}_0:text"]`)?.innerText);
}

## 📌 정리 요약

- Nexacro 그리드는 DOM id 패턴이 `gridrow_{row}.cell_{row}_{col}[:text]`로 **정형화**되어 있음
- 스크롤이 필요한 경우에는 **기존 row index를 재사용하여 새로운 데이터만 로딩**됨
- **중분류 ↔ 상품코드** 간 연결은 DOM id 구조만으로 정확히 추적 가능
\n## Nexacro_Rendering_Performance_20250723.md
# 📊 중분류 클릭 → 상품코드 렌더링 시간 측정 결과

## ✅ 테스트 개요

- **테스트 일시:** 2025-07-23 16:28:08
- **테스트 환경:** Chrome 개발자 도구 콘솔 (DevTools)
- **대상 화면:** 매출분석 > 중분류별 매출 구성비
- **중분류 코드:** `031` (반찬류)

---

## 🧪 측정 흐름

1. 중분류 코드 `031` 셀 클릭
2. Nexacro 트랜잭션 `searchDetail` 호출
3. 상품코드(`gdDetail`) 셀 DOM에 렌더링
4. 첫 번째 상품 셀 등장 시간 기록

---

## 📈 측정 결과

| 항목 | 값 |
|------|----|
| 트랜잭션 호출 시각 | `2025-07-23 16:28:08.914` |
| 상품코드 렌더링 완료 시각 | `2025-07-23 16:28:09` |
| **렌더링 소요 시간** | `567.5ms` |

---

## 🔍 분석 및 해석

- Nexacro 내부 트랜잭션 응답 및 데이터 바인딩 성능은 **정상적이며 빠름**
- DOM 렌더링까지 평균 500~600ms 소요
- **자동화 wait 기준은 최소 700ms 이상 확보가 안정적**

---

## ✅ 권장 사항

- `await delay(700)` 또는 `waitForTransaction('searchDetail')` 이후 `setTimeout(300~500ms)` 사용
- 타 중분류 항목에 대해 반복 측정하여 평균값 확보 가능
- 측정 결과를 바탕으로 자동화 스크립트의 타이밍 설계를 강화할 수 있음
\n## CODEX.md
[🔄 구조 보완 지시 사항]

1. 오른쪽 상품 grid는 항상 gridrow_0 구조로 렌더링되나, 실제 DOM의 셀 id가 고정되어 있지 않음.
   → 반드시 querySelector로 실시간 존재하는 셀 탐색 필요

2. 왼쪽 코드 클릭 후 오른쪽 상품이 로딩되기 전 바로 접근하면 정보 추출 실패함
   → 최소 1초 대기 또는 gridrow_0.cell_0_0:text 존재 여부 확인 후 진행

3. 셀 탐색 실패 시 경고 로그 출력 후 넘어가는 전략 필요
   → 자동화 전체 중단 방지

4. 클릭 대상은 항상 `.cell_X_Y`이며, 텍스트는 `.cell_X_Y:text`에서 추출함

5. 오른쪽 상품 행 순회 시에는 화면에 표시된 행만을 대상으로 하고,
   스크롤 버튼 클릭 후 갱신된 행을 다시 탐색해야 함
6. 메뉴 탐색 시 ``div.nexatextitem`` 안의 텍스트로 XPath를 구성하고,
   대소문자와 공백 차이를 무시하여 일치하는 첫 항목을 클릭한다.
7. Python 진입점 `main.py` 에서 `scripts/` 폴더의 스크립트를 차례로 실행해
   데이터를 추출하고 텍스트 파일로 저장한다.
