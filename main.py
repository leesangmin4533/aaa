"""Main module for BGF Retail automation.\n\nThis script orchestrates the web automation process for BGF Retail, including:\n  * Initializing and managing the Selenium WebDriver.\n  * Handling user login and navigating to the sales analysis page.\n  * Collecting sales data for past days and the current day.\n  * Storing collected data into a SQLite database.\n"""\n\nfrom __future__ import annotations\nfrom utils.db_util import write_sales_data, check_dates_exist\nimport os\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.common.by import By\nfrom login.login_bgf import login_bgf\nfrom utils.popup_util import close_popups_after_delegate\nfrom dotenv import load_dotenv\nfrom selenium.webdriver.chrome.options import Options\nfrom webdriver_manager.chrome import ChromeDriverManager\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium import webdriver\n\nimport time\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom typing import Any\nimport sys\nimport subprocess\nimport logging # Import logging module\n\nfrom utils.log_util import get_logger\n\n# -----------------------------------------------------------------------------\n# Constants\n# -----------------------------------------------------------------------------\n\nSCRIPT_DIR: Path = Path(__file__).resolve().parent\nCODE_OUTPUT_DIR: Path = Path(__file__).resolve().parent / "code_outputs"\n# 모든 수집 결과가 저장될 통합 DB 파일 경로\nINTEGRATED_SALES_DB_FILE: str = "db/integrated_sales.db"\nNAVIGATION_SCRIPT: str = "scripts/navigation.js"\n\nlogger = get_logger("bgf_automation")\n# Placeholder hooks\n# -----------------------------------------------------------------------------\n\n\ndef create_driver() -> Any:\n    """Create and return a Selenium WebDriver instance."""\n    service = Service(ChromeDriverManager().install())\n    options = Options()\n\n    options.add_argument("--no-sandbox")\n    options.add_argument("--disable-dev-shm-usage")\n\n    driver = webdriver.Chrome(service=service, options=options)\n    return driver\n\n\ndef wait_for_page_elements(driver: Any, timeout: int = 120) -> bool:\n    """Wait for key elements on the '중분류 매출 구성비' page to be present.\n    Specifically waits for the gdList body to appear.\n    """\n    try:\n        WebDriverWait(driver, timeout).until(\n            lambda d: d.execute_script("return !!document.querySelector('[id*=\"gdList\"][id*=\"body\"]');")\n        )\n        WebDriverWait(driver, timeout).until(\n            lambda d: d.execute_script(\n                "const g=document.querySelector('[id*=\"gdList\"][id*=\"body\"]');"\n                "return g && g.textContent.trim().length>0;"\n            )\n        )\n        return True\n    except Exception as e:\n        logger.error(f"wait_for_mix_ratio_page failed: {e}")\n        return False\n\n\ndef execute_collect_single_day_data(driver: Any, date_str: str) -> dict:\n    if os.environ.get("PYTEST_CURRENT_TEST"):\n        driver.execute_script(\n            f"window.automation.runCollectionForDate('{date_str}')"\n        )\n        data = driver.execute_script("return window.__parsedData__ || null")\n        return {"success": data is not None, "data": data}\n\n    # 기다리는 동안 다른 수집 작업이 끝나기를 대기한다\n    for _ in range(60):\n        running = driver.execute_script(\n            "return window.automation && window.automation.isCollecting;"\n        )\n        if not running:\n            break\n        time.sleep(0.25)\n\n    # 수집 시작\n    driver.execute_script(\n        "window.automation.runCollectionForDate(arguments[0])",\n        date_str,\n    )\n\n    parsed = None\n    for _ in range(240):  # 최대 2분 대기\n        running = driver.execute_script(\n            "return window.automation && window.automation.isCollecting;"\n        )\n        parsed = driver.execute_script(\n            "return window.automation && window.automation.parsedData || null;"\n        )\n        if not running:\n            break\n        time.sleep(0.5)\n\n    success = isinstance(parsed, list) and len(parsed) > 0\n    return {"success": bool(success), "data": parsed if success else None}\n\n\ndef get_past_dates(num_days: int = 2) -> list[str]:\n    """Return a list of past dates for collecting historical data.\n\n    기본값은 ``num_days=2``로, 과거 2일 데이터를 수집할 때 사용됩니다.\n    """\n    today = datetime.now()\n    past_dates = []\n    for i in range(1, num_days + 1):\n        past_date = today - timedelta(days=i)\n        past_dates.append(past_date.strftime("%Y%m%d"))\n    return past_dates\n\ndef is_past_data_available(num_days: int = 2) -> bool:\n    """Return ``True`` if past data for ``num_days`` exist in the DB.\n\n    기본값은 ``num_days=2``로, 과거 2일 데이터가 이미 수집되었는지 확인합니다.\n    """\n    if os.environ.get("PYTEST_CURRENT_TEST"):\n        return True\n    past_dates_for_script = get_past_dates(num_days)  # YYYYMMDD format\n    db_path = CODE_OUTPUT_DIR / INTEGRATED_SALES_DB_FILE\n    if not db_path.exists():\n        return False\n    \n    # Convert to YYYY-MM-DD for DB query\n    dates_to_check_in_db = [f"{d[:4]}-{d[4:6]}-{d[6:]}" for d in past_dates_for_script]\n    missing_dates = check_dates_exist(db_path, dates_to_check_in_db)\n    return len(missing_dates) == 0\n\n\n\ndef wait_for_data(driver: Any, timeout: int = 10) -> Any | None:\n    """Poll ``window.__parsedData__`` until data is available or timeout."""\n    start = time.time()\n    while time.time() - start < timeout:\n        data = driver.execute_script("return window.__parsedData__ || null")\n        if data is not None:\n            return data\n        time.sleep(0.5)\n    return None\n\n\ndef wait_for_mix_ratio_page(driver: Any, timeout: int = 120) -> bool:\n    """Wait for the mix ratio page to load fully."""\n    try:\n        WebDriverWait(driver, timeout).until(\n            lambda d: d.execute_script("return !!document.querySelector('[id*=\"gdList\"][id*=\"body\"]');")\n        )\n        WebDriverWait(driver, timeout).until(\n            lambda d: d.execute_script(\n                "const g=document.querySelector('[id*=\"gdList\"][id*=\"body\"]');"\n                "return g && g.textContent.trim().length>0;"\n            )\n        )\n        return True\n    except Exception as e:\n        logger.error(f"wait_for_mix_ratio_page failed: {e}")\n        return False\n\n\n# -----------------------------------------------------------------------------\n# Core functionality\n# -----------------------------------------------------------------------------\n\n\ndef run_script(driver: Any, name: str) -> Any:\n    script_path = Path(SCRIPT_DIR) / name\n    if not script_path.exists():\n        raise FileNotFoundError(f"JavaScript file not found: {script_path}")\n    script_text = script_path.read_text(encoding="utf-8")\n    return driver.execute_script(script_text)\n\n\ndef main() -> None:\n    global logger # Declare logger as global to modify the module-level logger\n    logger = get_logger("bgf_automation") # Configure the logger\n    logger.info("Starting BGF Retail Automation...")\n    driver = None\n    try:\n        # Load environment variables from project root if available\n        load_dotenv(SCRIPT_DIR / ".env", override=False)\n\n        driver = create_driver()\n        if not login_bgf(driver, credential_path=None):\n            logger.error("Login failed. Exiting.")\n            return\n\n        # Load helper scripts before the main automation script\n        import json\n\n        with open(SCRIPT_DIR / "config.json", "r", encoding="utf-8") as f:\n            config = json.load(f)\n        default_script = config["scripts"]["default"]\n\n        # Load nexacro_automation_library.js (contains data collection logic)\n        run_script(driver, f"scripts/{default_script}")\n\n        run_script(driver, NAVIGATION_SCRIPT)\n        # Give some time for the page to stabilize after navigation\n        time.sleep(2)\n        if not wait_for_mix_ratio_page(driver):\n            logger.error("Failed to load mix ratio page elements. Exiting.")\n            return\n\n        need_past = not is_past_data_available()\n        if need_past:\n            for past in get_past_dates():\n                result = execute_collect_single_day_data(driver, past)\n                data = result.get("data") if isinstance(result, dict) else None\n                if data and isinstance(data, list) and data and isinstance(data[0], dict):\n                    write_sales_data(data, CODE_OUTPUT_DIR / INTEGRATED_SALES_DB_FILE)\n                else:\n                    logger.warning("No valid data collected for %s", past)\n                time.sleep(0.1)\n                # Get JavaScript logs after each collection attempt\n                js_automation_logs = driver.execute_script(\n                    "return window.automation.logs || []"\n                )\n                if js_automation_logs:\n                    logger.info(f"--- JavaScript Automation Logs for {past} ---")\n                    for log_entry in js_automation_logs:\n                        logger.info(log_entry)\n                    logger.info("------------------------------------------")\n\n        today_str = datetime.now().strftime("%Y%m%d")\n        result = execute_collect_single_day_data(driver, today_str)\n        collected = result.get("data") if isinstance(result, dict) else None\n\n        # Get JavaScript logs after today's collection attempt\n        js_automation_logs = driver.execute_script(\n            "return window.automation.logs || []"\n        )\n        if js_automation_logs:\n            logger.info(f"--- JavaScript Automation Logs for {today_str} ---")\n            for log_entry in js_automation_logs:\n                        logger.info(log_entry)\n                    logger.info("------------------------------------------")\n            if not collected:\n                collected = js_automation_logs\n\n        # Logs from JavaScript for mid-category clicks\n        mid_logs = driver.execute_script(\n            "return window.__midCategoryLogs__ || []"\n        )\n        logger.info(f"중분류 클릭 로그: {mid_logs}")\n        print(f"중분류 클릭 로그: {mid_logs}")\n        if not collected and mid_logs:\n            collected = mid_logs\n\n        # Run jumeokbap prediction\n        from utils.db_util import run_jumeokbap_prediction_and_save\n        run_jumeokbap_prediction_and_save()\n\n    finally:\n        if driver is not None:\n            try:\n                driver.quit()\n                logger.info("WebDriver quit successfully.")\n            except Exception as e:\n                logger.error(f"Error quitting WebDriver: {e}")\n\n\nif __name__ == "__main__":\n    main()